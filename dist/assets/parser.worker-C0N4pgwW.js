(function(){"use strict";function u(o){const e=o.split(/(?=; action = \w+)/g),t=e.find(n=>n.includes("; action = lmem_assign")&&n.includes("; step = lmem_spec")),s={};if(t){const n=/;\s*(\w+)\s*=\s*([^;]+)/gi;let i;for(;(i=n.exec(t))!==null;){const[,c,m]=i;["lmem_bytes","lmem_banks","lmem_bank_bytes"].includes(c)&&(s[c]=Number(m.trim()))}console.log("[extractValidSections] 芯片信息:",s)}const r=e.filter(n=>n.includes("; action = lmem_assign")&&n.includes("; tag = iteration_result")&&!n.includes("; step = lmem_spec")),a=e.filter(n=>n.includes("; action = timestep_assign")&&n.includes("; tag = final_result")).slice(-1);return{lmemSections:r,timestepSections:a,chip:s}}class _{static FIELDS_WHITELIST=new Set(["op_name","op_type","addr","size","timestep_start","timestep_end","lmem_type","hold_in_lmem","status","tag","bank_id"]);parse(e){const t=this._groupBySettings(e);return this._processAllocationGroups(t)}_groupBySettings(e){const t=[];let s=null;return e.forEach(r=>{const{entry:a,settings:n}=this._parseSection(r);a&&((!s||!this._isSameSettings(s.settings,n))&&(s={settings:n,allocations:[]},t.push(s)),s.allocations.push(a))}),t}_parseSection(e){const t={},s={},r=/; (\w+) = ([^;]+)/g;let a;for(;(a=r.exec(e))!==null;){const[n,i,c]=a,m=this._convertValue(i,c.trim());(i==="shape_secs"||i==="allow_bank_conflict")&&(s[i]=m),this.constructor.FIELDS_WHITELIST.has(i)&&(t[i]=m)}return{entry:this._validateEntry(t),settings:s}}_processAllocationGroups(e){return e.map(t=>{const{settings:s,allocations:r}=t,{success:a,failed:n}=this._splitByStatus(r);let c=a.reduce((l,p)=>Math.max(l,p.addr+p.size),0);const m=n.map(l=>{const p={...l,addr:c};return c+=l.size,p}),f=Math.max(...a.map(l=>l.timestep_end),...n.map(l=>l.timestep_end));return{settings:s,allocations:[...a,...m].map(l=>({...l,bank_id:l.addr>>16&15,max_timestep:f}))}})}_splitByStatus(e){return e.reduce((t,s)=>(s.status==="success"?t.success.push(s):t.failed.push(s),t),{success:[],failed:[]})}_isSameSettings(e,t){return["shape_secs","allow_bank_conflict"].every(s=>JSON.stringify(e[s])===JSON.stringify(t[s]))}_convertValue(e,t){return t=t.trim(),["hold_in_lmem","allow_bank_conflict","one_loop"].includes(e)?t==="1"||t.toLowerCase()==="true":t.startsWith("0x")?parseInt(t,16):isNaN(t)?e==="shape_secs"?t.split(",").map(Number):t.startsWith('"')&&t.endsWith('"')?t.slice(1,-1):t:Number(t)}_validateEntry(e){return e.tag==="stamp"?null:["op_name","addr","size","timestep_start","timestep_end","status","tag"].every(s=>s in e)&&e.tag==="iteration_result"?e:null}}class d{parse(e){return e.length===0?[]:e[0].split(`
`).filter(r=>r.includes("; ts =")).map(r=>{try{return this._parseTimestepLine(r)}catch(a){return console.warn("解析timestep行失败:",a.message),null}}).filter(Boolean)}_parseTimestepLine(e){const t=e.match(/; ts = (\d+);/);if(!t)throw new Error("无效的时间步格式");return{ts:parseInt(t[1]),compute:this._extractOperations(e,"C"),loads:this._extractOperations(e,"L"),stores:this._extractOperations(e,"S")}}_extractOperations(e,t){if(t==="C"){const r=/C\("([^"]+)"\)[^"]*"([^"]+)"/g;return[...e.matchAll(r)].map(([a,n,i])=>({id:`${i}`,type:"compute",operation:`${n}`}))}const s=new RegExp(`${t}\\("([^"]+)", hold_in_lmem = (\\d)\\)->([^,\\]]+)`,"g");return[...e.matchAll(s)].map(([r,a,n,i])=>({id:a,hold_in_lmem:parseInt(n),target:i,type:t==="C"?"compute":t.toLowerCase()}))}}function g(o,e){const t=new Map(o.map(s=>[s.op_name,s]));return e.map(s=>({...s,compute:s.compute.map(r=>({...r,memory_allocation:t.get(r.id)})),memory_usage:h(s.ts,o)}))}function h(o,e){return e.filter(t=>{const s=Number(t.timestep_start),r=Number(t.timestep_end);return isNaN(s)||isNaN(r)?!1:s<=o&&r>=o}).reduce((t,s)=>{const r=Number(s.size);return isNaN(r)?t:t+r},0)}self.onmessage=async o=>{const e=o.data;try{if(!e||typeof e!="string")throw new Error("Invalid input: rawLog must be a non-empty string");const{lmemSections:t,timestepSections:s,chip:r}=u(e);if(!t.length||!s.length)throw new Error("No valid sections found in the log file");const a=new _,n=new d,i=a.parse(t),c=n.parse(s);if(i.length&&r&&Object.assign(i[0].settings,r),console.log("[Worker] lmemData after chip merge:",i),!i||!c)throw new Error("Parser returned invalid data");const m=g(i[0].allocations,c);self.postMessage({lmem:i,timestep:c,summary:m})}catch(t){console.error("[Worker]",t),self.postMessage({error:t.message})}}})();
